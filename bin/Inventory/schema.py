# Copyright (c) 2023 Trail of Bits, Inc., all rights reserved.

from abc import ABC, abstractmethod
from typing import Dict, List, Optional


class Schema(ABC):
  """Abstract schema."""

  def __str__(self) -> str:
    return self.__class__.__name__[:-6]  # `-len("Schema")`.


class NamedSchema(Schema, ABC):
  """Represents a schema for something with a name."""
  name: str

  def __init__(self, name: str):
    super().__init__()
    self.name = name

  def __str__(self) -> str:
    return self.name


class UnknownSchema(Schema):
  """Represents some unknown type."""
  pass


class VarSchema(NamedSchema):
  element_type: Schema

  def __init__(self, name: str, element_type: Schema):
    super().__init__(name)
    self.element_type = element_type

  def dump(self, indent: str):
    print(f"{indent}{self.name} :: {self.element_type}")


class MethodSchema(NamedSchema):
  return_type: Schema
  parameters: List[VarSchema]
  is_const: bool

  def __init__(self, name: str, return_type: Schema):
    super().__init__(name)
    self.return_type = return_type
    self.parameters = []
    self.is_const = False

  def dump(self, indent: str):
    params = ""
    if len(self.parameters):
      params = " -> ".join("({} {})".format(p.element_type, p.name) for p in self.parameters)
      params += " -> "
    print(f"{indent}{self.name} :: {params}{self.return_type}")


class ClassSchema(NamedSchema, ABC):
  """Represents a schema for an arbitrary class in the Multiplier API. This
  is an abstract class."""

  # Relative path to the file where this alias is defined.
  location: str

  # Bases classes, if any, of this class.
  bases: List['ClassSchema']

  # Public instance and static members.
  members: Dict[str, VarSchema]
  static_members: Dict[str, VarSchema]

  # Public methods, and public static methods.
  constructors: List[MethodSchema]
  methods: Dict[str, MethodSchema]
  static_methods: Dict[str, MethodSchema]

  # Does this class support `operator bool` in C++?
  has_boolean_conversion: bool

  # Does this class support iteration? If so, this is the deduced value type
  # generated by the iterable.
  generated_type: Optional[Schema]

  # Nested schemas, e.g. nested enums, classes, etc.
  nested_schemas: Dict[str, Schema]

  def __init__(self, name: str):
    super().__init__(name)
    self.bases = []
    self.constructors = []
    self.members = {}
    self.static_members = {}
    self.methods = {}
    self.static_methods = {}
    self.has_boolean_conversion = False
    self.generated_type = None
    self.nested_schemas = {}

  def _dump_section(self, indent: str, section_name: str, data: Dict[str, Schema]):
    if not len(data):
      return

    next_indent = indent + "    "
    print(f"{indent}  {section_name}")
    for member in data.values():
      member.dump(next_indent)


  def dump(self, indent: str):
    print(f"{indent}CLASS {self.name}")
    print(f"{indent}  LOCATION {self.location}")
    
    if len(self.bases):
      print("{}  BASE_CLASSES {}".format(indent, ", ".join(str(base) for base in self.bases)))

    if self.has_boolean_conversion:
      print(f"{indent}  HAS_BOOLEAN_CONVERSION")

    if self.generated_type is not None:
      print(f"{indent}  GENERATES {self.generated_type}")

    self._dump_section(indent, "NESTED_SCHEMAS", self.nested_schemas)
    self._dump_section(indent, "FIELDS", self.members)
    self._dump_section(indent, "VARIABLES", self.static_members)
    self._dump_section(indent, "METHODS", self.methods)
    self._dump_section(indent, "STATIC_METHODS", self.static_methods)


class StringLikeSchema(Schema, ABC):
  pass


class CStringSchema(StringLikeSchema):
  """Corresponds to a `const char *`."""
  pass


class StdStringSchema(StringLikeSchema):
  """Corresponds to a `std::string`."""
  pass


class StdStringViewSchema(StringLikeSchema):
  """Corresponds to a `std::string_view`."""
  pass


class StdFilesystemPathSchema(StringLikeSchema):
  """Corresponds to a `std::filesystem::path`."""
  pass


class LLVMStringRefSchema(StringLikeSchema):
  """Corresponds to an `llvm::StringRef`."""
  pass


class LLVMTwineSchema(StringLikeSchema):
  """Corresponds to an `llvm::Twine`."""
  pass


class ParameterizedSchema(Schema, ABC):
  """Corresponds to a parameterized schema, e.g. `type<T>` in C++."""
  element_type: Schema

  def __init__(self, element_type: Schema):
    super().__init__()
    self.element_type = element_type

  def __str__(self) -> str:
    class_prefix = self.__class__.__name__[:-6]  # `-len("Schema")`.
    return f"{class_prefix}[{self.element_type}]"


class StdOptionalSchema(ParameterizedSchema):
  """Corresponds to a `std::optional<T>`."""
  pass


class ListLikeSchema(ParameterizedSchema, ABC):
  """Represents list-like things."""
  pass


class StdVectorSchema(ListLikeSchema):
  """Corresponds to a `std::vector<T>`."""
  pass


class GapGeneratorSchema(ListLikeSchema):
  """Corresponds to a `gap::generator<T>`."""
  pass


class ClangAPInt(Schema):
  """Corresponds to a `clang::APInt`."""
  pass


class ClangAPSInt(Schema):
  """Corresponds to a `clang::APSInt`."""
  pass


class ClangAPFloat(Schema):
  """Corresponds to a `clang::APFloat`."""
  pass


class ClangASTContextSchema(Schema):
  """Corresponds to a `clang::ASTContext`."""
  pass


class BuiltinTypeSchema(Schema, ABC):
  """Corresponds to a builtin type in C/C++."""
  pass


class BooleanSchema(BuiltinTypeSchema):
  """Corresponds to a `bool` type in C++ and a `_Bool` type in C."""
  pass


class IntegerSchema(BuiltinTypeSchema, ABC):
  """Any integral type in C/C++."""
  size_in_bits: int
  is_signed: bool

  def __init__(self, size_in_bits: int, is_signed: bool):
    super().__init__()
    self.size_in_bits = size_in_bits
    self.is_signed = is_signed


class Int8Schema(IntegerSchema):
  """Corresponds to a `char`, `signed char`, or `int8_t` in C/C++."""
  def __init__(self):
    super().__init__(8, True)


class Int16Schema(IntegerSchema):
  """Corresponds to a `short`, `signed short`, or `int16_t` in C/C++."""
  def __init__(self):
    super().__init__(16, True)


class Int32Schema(IntegerSchema):
  """Corresponds to a `int`, `signed int`, or `int32_t` in C/C++."""
  def __init__(self):
    super().__init__(32, True)


class Int64Schema(IntegerSchema):
  """Corresponds to a `long`, `signed long`, or `long long`, `signed long long`,
  or an `int64_t` in C/C++."""
  def __init__(self):
    super().__init__(64, True)


class UInt8Schema(IntegerSchema):
  """Corresponds to a `unsigned char` or `uint8_t` in C/C++."""
  def __init__(self):
    super().__init__(8, False)


class UInt16Schema(IntegerSchema):
  """Corresponds to a `unsigned short` or `uint16_t` in C/C++."""
  def __init__(self):
    super().__init__(16, False)


class UInt32Schema(IntegerSchema):
  """Corresponds to a `unsinged`, `unsigned int`, or `uint32_t` in C/C++."""
  def __init__(self):
    super().__init__(32, False)


class UInt64Schema(IntegerSchema):
  """Corresponds to a `unsigned long`, `unsigned long long`, or an `uint64_t`
  in C/C++."""

  def __init__(self):
    super().__init__(64, False)


class FloatingPointSchema(BuiltinTypeSchema, ABC):
  """Corresponds to any floating point type in C/C++."""
  size_in_bits: int

  def __init__(self, size_in_bits: int):
    super().__init__()
    self.size_in_bits = size_in_bits


class FloatSchema(FloatingPointSchema):
  """Corresponds to a `float` in C/C++."""

  def __init__(self):
    super().__init__(32)


class DoubleSchema(FloatingPointSchema):
  """Corresponds to a `double` in C/C++."""

  def __init__(self):
    super().__init__(64)


class EnumSchema(NamedSchema):
  """Corresponds to an `enum` type in C/C++."""

  # Relative path to the file where this enum is defined.
  location: str

  # Underlying integer type of this enum
  base_type: 'IntegerSchema'

  # Named list of enumerators.
  enumerators: [str]

  # Is this an `enum class` in C++?
  is_scoped: bool

  # Is the underlying type explicitly specified?
  is_explicitly_typed: bool

  def __init__(self, name: str, is_scoped: bool, base_type: 'IntegerSchema'):
    super().__init__(name)
    self.base_type = base_type
    self.enumerators = []
    self.is_scoped = is_scoped
    self.is_explicitly_typed = False

  def dump(self, indent: str):
    scoped = self.is_scoped and "_CLASS" or ""
    explicit = self.is_explicitly_typed and "EXPLICIT_" or ""
    print(f"{indent}ENUM{scoped} {self.name}")
    print(f"{indent}  LOCATION {self.location}")
    print(f"{indent}  {explicit}BASE_TYPE {self.base_type}")
    print(f"{indent}  ENUMERATORS")
    for enumerator in self.enumerators:
      print(f"{indent}    {enumerator}")


class AliasSchema(NamedSchema):
  """Corresponds to a `using` or `typedef` type in C/C++."""

  # Relative path to the file where this alias is defined.
  location: str

  base_type: Schema

  def __init__(self, name: str, base_type: Schema):
    super().__init__(name)
    self.base_type = base_type

  def __str__(self) -> str:
    return f"Alias[{self.name},{self.base_type}]"

  def dump(self, indent: str):
    print(f"{indent}ALIAS {self.name}")
    print(f"{indent}  LOCATION {self.location}")
    print(f"{indent}  BASE_TYPE {self.base_type}")


class PointerLikeSchema(ParameterizedSchema, ABC):
  """Corresponds to something pointer-like."""


class RawPointerSchema(PointerLikeSchema):
  """Corresponds to a `T *` in C/C++."""
  pass


class StdUniquePtrSchema(PointerLikeSchema):
  """Corresponds to a `std::unique_ptr<T>` in C/C++."""
  pass


class StdSharedPtrSchema(PointerLikeSchema):
  """Corresponds to a `std::shared_ptr<T>` in C/C++."""
  pass
